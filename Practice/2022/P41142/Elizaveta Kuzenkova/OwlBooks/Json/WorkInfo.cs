// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var workInfo = WorkInfo.FromJson(jsonString);

namespace Json.Work.QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class WorkInfo
    {
        [JsonProperty("authors", NullValueHandling = NullValueHandling.Ignore)]
        public List<AuthorRole> Authors { get; set; }

        [JsonProperty("covers", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Covers { get; set; }

        [JsonProperty("created", NullValueHandling = NullValueHandling.Ignore)]
        public InternalDatetime Created { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public TextBlock Description { get; set; }

        [JsonProperty("first_publish_date", NullValueHandling = NullValueHandling.Ignore)]
        public string FirstPublishDate { get; set; }

        /// <summary>
        /// Unsure what this is for, deprecate?
        /// </summary>
        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public double? Id { get; set; }

        [JsonProperty("key")]
        public string Key { get; set; }

        [JsonProperty("last_modified")]
        public InternalDatetime LastModified { get; set; }

        [JsonProperty("latest_revision", NullValueHandling = NullValueHandling.Ignore)]
        public double? LatestRevision { get; set; }

        [JsonProperty("lc_classifications", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> LcClassifications { get; set; }

        [JsonProperty("links", NullValueHandling = NullValueHandling.Ignore)]
        public List<Link> Links { get; set; }

        [JsonProperty("notes", NullValueHandling = NullValueHandling.Ignore)]
        public TextBlock Notes { get; set; }

        [JsonProperty("revision")]
        public double Revision { get; set; }

        [JsonProperty("subjects", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Subjects { get; set; }

        [JsonProperty("subtitle", NullValueHandling = NullValueHandling.Ignore)]
        public string Subtitle { get; set; }

        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("type")]
        public WorkInfoType Type { get; set; }
    }

    public partial class AuthorRole
    {
        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public string As { get; set; }

        [JsonProperty("author")]
        public Author Author { get; set; }

        [JsonProperty("role", NullValueHandling = NullValueHandling.Ignore)]
        public string Role { get; set; }

        [JsonProperty("type")]
        public AuthorType Type { get; set; }
    }

    public partial class Author
    {
        [JsonProperty("key")]
        public string Key { get; set; }
    }

    public partial class AuthorType
    {
        [JsonProperty("key")]
        public PurpleKey Key { get; set; }
    }

    public partial class InternalDatetime
    {
        [JsonProperty("type")]
        public CreatedType Type { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class TextBlock
    {
        [JsonProperty("type")]
        public DescriptionType Type { get; set; }

        [JsonProperty("value")]
        public string Value { get; set; }
    }

    public partial class Link
    {
        [JsonProperty("title")]
        public string Title { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public LinkType Type { get; set; }

        [JsonProperty("url")]
        public string Url { get; set; }
    }

    public partial class LinkType
    {
        [JsonProperty("key")]
        public FluffyKey Key { get; set; }
    }

    public partial class WorkInfoType
    {
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public TentacledKey? Key { get; set; }
    }

    public enum PurpleKey { TypeAuthorRole };

    public enum CreatedType { TypeDatetime };

    public enum DescriptionType { TypeText };

    public enum FluffyKey { TypeLink };

    public enum TentacledKey { TypeWork };

    public partial class WorkInfo
    {
        public static WorkInfo FromJson(string json) => JsonConvert.DeserializeObject<WorkInfo>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this WorkInfo self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                PurpleKeyConverter.Singleton,
                CreatedTypeConverter.Singleton,
                DescriptionTypeConverter.Singleton,
                FluffyKeyConverter.Singleton,
                TentacledKeyConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class PurpleKeyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PurpleKey) || t == typeof(PurpleKey?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "/type/author_role")
            {
                return PurpleKey.TypeAuthorRole;
            }
            throw new Exception("Cannot unmarshal type PurpleKey");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PurpleKey)untypedValue;
            if (value == PurpleKey.TypeAuthorRole)
            {
                serializer.Serialize(writer, "/type/author_role");
                return;
            }
            throw new Exception("Cannot marshal type PurpleKey");
        }

        public static readonly PurpleKeyConverter Singleton = new PurpleKeyConverter();
    }

    internal class CreatedTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CreatedType) || t == typeof(CreatedType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "/type/datetime")
            {
                return CreatedType.TypeDatetime;
            }
            throw new Exception("Cannot unmarshal type CreatedType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CreatedType)untypedValue;
            if (value == CreatedType.TypeDatetime)
            {
                serializer.Serialize(writer, "/type/datetime");
                return;
            }
            throw new Exception("Cannot marshal type CreatedType");
        }

        public static readonly CreatedTypeConverter Singleton = new CreatedTypeConverter();
    }

    internal class DescriptionTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DescriptionType) || t == typeof(DescriptionType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "/type/text")
            {
                return DescriptionType.TypeText;
            }
            throw new Exception("Cannot unmarshal type DescriptionType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DescriptionType)untypedValue;
            if (value == DescriptionType.TypeText)
            {
                serializer.Serialize(writer, "/type/text");
                return;
            }
            throw new Exception("Cannot marshal type DescriptionType");
        }

        public static readonly DescriptionTypeConverter Singleton = new DescriptionTypeConverter();
    }

    internal class FluffyKeyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FluffyKey) || t == typeof(FluffyKey?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "/type/link")
            {
                return FluffyKey.TypeLink;
            }
            throw new Exception("Cannot unmarshal type FluffyKey");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FluffyKey)untypedValue;
            if (value == FluffyKey.TypeLink)
            {
                serializer.Serialize(writer, "/type/link");
                return;
            }
            throw new Exception("Cannot marshal type FluffyKey");
        }

        public static readonly FluffyKeyConverter Singleton = new FluffyKeyConverter();
    }

    internal class TentacledKeyConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TentacledKey) || t == typeof(TentacledKey?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "/type/work")
            {
                return TentacledKey.TypeWork;
            }
            throw new Exception("Cannot unmarshal type TentacledKey");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TentacledKey)untypedValue;
            if (value == TentacledKey.TypeWork)
            {
                serializer.Serialize(writer, "/type/work");
                return;
            }
            throw new Exception("Cannot marshal type TentacledKey");
        }

        public static readonly TentacledKeyConverter Singleton = new TentacledKeyConverter();
    }
}
